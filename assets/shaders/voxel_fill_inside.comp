layout(binding = 0, rgba16f) uniform restrict image3D uTex3D;
uniform vec3 uFillColor;
uniform int uWalkDirection = 2; // 0 = x, 1 = y, 2 = z

bool isEmpty(vec4 value)
{
    return length(value.rgb) == 0 || value.a == 0.5;
}

// HOWTO USE
// set uTex3D to GL_READ_WRITE
// run this shader for all three walk directions, with glMemoryBarrier in between
// in glDispatchCompute call leave the walking direction group count at 1
// e.g. glDispatchCompute(<width of uTex3D>, <height of uTex3D>, 1) for uWalkDirection = 2
//
// HOW IT WORKS
// in each call, threads march in a given direction, and mark inside voxels as candidates
// if a voxel is a candidate in all three direction, it is inside and filled

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in; // layout declaration
void main()
{
    int depth = 64; // TODO imageSize(uTex3D) instead of constant
    ivec3 pos = ivec3(0);
    int onSurface = 0;
    int countSurfaceCrossings = 0;
    vec4 lastValue = vec4(0);
    vec4 value = vec4(0);

    // each thread walks along its 2D position in the third direction, e.g. at its xy pos along z direction
    // check if inside voxelized mesh surface via odd-even rule
    // voxelized mesh surface can have several voxel thickness, so check for empty after full voxel
    // if inside and empty, mark as candidate

    for (int i = 0; i < depth; ++i)
    {
        if (uWalkDirection == 0)
            pos = ivec3(i, gl_GlobalInvocationID.xy);
        else if (uWalkDirection == 1)
            pos = ivec3(gl_GlobalInvocationID.x, i, gl_GlobalInvocationID.y);
        else
            pos = ivec3(gl_GlobalInvocationID.xy, i);

        value = imageLoad(uTex3D, pos);

        if (isEmpty(lastValue) && !isEmpty(value)) // entered voxelized mesh surface
        {
            onSurface = 1;
        }
        if (!isEmpty(lastValue) && isEmpty(value)) // exited voxelized mesh surface
        {
            onSurface = 0;
            ++countSurfaceCrossings;
        }

        if (onSurface == 0 && mod(countSurfaceCrossings, 2) == 1) // probably inside in this direction
        {
            // alpha = 0.5 to mark as inside candidate, still counts as empty
            imageStore(uTex3D, pos, vec4(value.rgb, 0.5));
        }

        lastValue = value;
    }

    // now we certainly have all inside voxels marked
    // however at the end we may have false positive inside voxels
    // so we walk back and remove them

    onSurface = 0;
    countSurfaceCrossings = 0;
    lastValue = vec4(0);
    value = vec4(0);

    for (int i = depth - 1; i >= 0; --i)
    {
        if (uWalkDirection == 0)
            pos = ivec3(i, gl_GlobalInvocationID.xy);
        else if (uWalkDirection == 1)
            pos = ivec3(gl_GlobalInvocationID.x, i, gl_GlobalInvocationID.y);
        else
            pos = ivec3(gl_GlobalInvocationID.xy, i);
            value = imageLoad(uTex3D, pos);

        if (isEmpty(lastValue) && !isEmpty(value)) // entered voxelized mesh surface
        {
            onSurface = 1;
        }
        if (!isEmpty(lastValue) && isEmpty(value)) // exited voxelized mesh surface
        {
            onSurface = 0;
            ++countSurfaceCrossings;
        }

        if (onSurface == 0 && mod(countSurfaceCrossings, 2) == 0) // outside in this direction
        {
            imageStore(uTex3D, pos, vec4(0, 0, 0, 0));
        }

        if (value.a == 0.5)
        {
            // candidates have alpha 0.5 and still count as empty
            // store 1 for x y z to indicate that in this direction candidate is inside
            if (uWalkDirection == 0)
                value.x = 1;
            else if (uWalkDirection == 1)
                value.y = 1;
            else if (uWalkDirection == 2)
                value.z = 1;

            if (all(equal(value.rgb, vec3(1))))
            {
                imageStore(uTex3D, pos, vec4(uFillColor, 1));
            }
            else
            {
                imageStore(uTex3D, pos, value);
            }
        }

        lastValue = value;

    }

}


